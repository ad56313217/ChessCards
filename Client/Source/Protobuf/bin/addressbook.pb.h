// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: addressbook.proto

#ifndef PROTOBUF_addressbook_2eproto__INCLUDED
#define PROTOBUF_addressbook_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_addressbook_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[25];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPlayerDataImpl();
void InitDefaultsPlayerData();
void InitDefaultslogin_namepasswordReqImpl();
void InitDefaultslogin_namepasswordReq();
void InitDefaultslogin_DeviceReqImpl();
void InitDefaultslogin_DeviceReq();
void InitDefaultslogin_wechatReqImpl();
void InitDefaultslogin_wechatReq();
void InitDefaultslogin_ResponeImpl();
void InitDefaultslogin_Respone();
void InitDefaultsroom_createReqImpl();
void InitDefaultsroom_createReq();
void InitDefaultsroom_createResponeImpl();
void InitDefaultsroom_createRespone();
void InitDefaultsroom_joinReqImpl();
void InitDefaultsroom_joinReq();
void InitDefaultsroom_joinResponeImpl();
void InitDefaultsroom_joinRespone();
void InitDefaultsroom_playerReadyImpl();
void InitDefaultsroom_playerReady();
void InitDefaultsroom_playerReadyResponeImpl();
void InitDefaultsroom_playerReadyRespone();
void InitDefaultsroom_gamestartResponeImpl();
void InitDefaultsroom_gamestartRespone();
void InitDefaultspokerImpl();
void InitDefaultspoker();
void InitDefaultscallImpl();
void InitDefaultscall();
void InitDefaultscall_ResponeImpl();
void InitDefaultscall_Respone();
void InitDefaultscall_begin_ResponeImpl();
void InitDefaultscall_begin_Respone();
void InitDefaultspokeroutImpl();
void InitDefaultspokerout();
void InitDefaultspokerout_ResponeImpl();
void InitDefaultspokerout_Respone();
void InitDefaultsgameend_ResponeImpl();
void InitDefaultsgameend_Respone();
void InitDefaultschattextImpl();
void InitDefaultschattext();
void InitDefaultschatemoImpl();
void InitDefaultschatemo();
void InitDefaultschatstringImpl();
void InitDefaultschatstring();
void InitDefaultschattext_ResponeImpl();
void InitDefaultschattext_Respone();
void InitDefaultschatemo_ResponeImpl();
void InitDefaultschatemo_Respone();
void InitDefaultschatstring_ResponeImpl();
void InitDefaultschatstring_Respone();
inline void InitDefaults() {
  InitDefaultsPlayerData();
  InitDefaultslogin_namepasswordReq();
  InitDefaultslogin_DeviceReq();
  InitDefaultslogin_wechatReq();
  InitDefaultslogin_Respone();
  InitDefaultsroom_createReq();
  InitDefaultsroom_createRespone();
  InitDefaultsroom_joinReq();
  InitDefaultsroom_joinRespone();
  InitDefaultsroom_playerReady();
  InitDefaultsroom_playerReadyRespone();
  InitDefaultsroom_gamestartRespone();
  InitDefaultspoker();
  InitDefaultscall();
  InitDefaultscall_Respone();
  InitDefaultscall_begin_Respone();
  InitDefaultspokerout();
  InitDefaultspokerout_Respone();
  InitDefaultsgameend_Respone();
  InitDefaultschattext();
  InitDefaultschatemo();
  InitDefaultschatstring();
  InitDefaultschattext_Respone();
  InitDefaultschatemo_Respone();
  InitDefaultschatstring_Respone();
}
}  // namespace protobuf_addressbook_2eproto
namespace ccg_pb {
class PlayerData;
class PlayerDataDefaultTypeInternal;
extern PlayerDataDefaultTypeInternal _PlayerData_default_instance_;
class call;
class callDefaultTypeInternal;
extern callDefaultTypeInternal _call_default_instance_;
class call_Respone;
class call_ResponeDefaultTypeInternal;
extern call_ResponeDefaultTypeInternal _call_Respone_default_instance_;
class call_begin_Respone;
class call_begin_ResponeDefaultTypeInternal;
extern call_begin_ResponeDefaultTypeInternal _call_begin_Respone_default_instance_;
class chatemo;
class chatemoDefaultTypeInternal;
extern chatemoDefaultTypeInternal _chatemo_default_instance_;
class chatemo_Respone;
class chatemo_ResponeDefaultTypeInternal;
extern chatemo_ResponeDefaultTypeInternal _chatemo_Respone_default_instance_;
class chatstring;
class chatstringDefaultTypeInternal;
extern chatstringDefaultTypeInternal _chatstring_default_instance_;
class chatstring_Respone;
class chatstring_ResponeDefaultTypeInternal;
extern chatstring_ResponeDefaultTypeInternal _chatstring_Respone_default_instance_;
class chattext;
class chattextDefaultTypeInternal;
extern chattextDefaultTypeInternal _chattext_default_instance_;
class chattext_Respone;
class chattext_ResponeDefaultTypeInternal;
extern chattext_ResponeDefaultTypeInternal _chattext_Respone_default_instance_;
class gameend_Respone;
class gameend_ResponeDefaultTypeInternal;
extern gameend_ResponeDefaultTypeInternal _gameend_Respone_default_instance_;
class login_DeviceReq;
class login_DeviceReqDefaultTypeInternal;
extern login_DeviceReqDefaultTypeInternal _login_DeviceReq_default_instance_;
class login_Respone;
class login_ResponeDefaultTypeInternal;
extern login_ResponeDefaultTypeInternal _login_Respone_default_instance_;
class login_namepasswordReq;
class login_namepasswordReqDefaultTypeInternal;
extern login_namepasswordReqDefaultTypeInternal _login_namepasswordReq_default_instance_;
class login_wechatReq;
class login_wechatReqDefaultTypeInternal;
extern login_wechatReqDefaultTypeInternal _login_wechatReq_default_instance_;
class poker;
class pokerDefaultTypeInternal;
extern pokerDefaultTypeInternal _poker_default_instance_;
class pokerout;
class pokeroutDefaultTypeInternal;
extern pokeroutDefaultTypeInternal _pokerout_default_instance_;
class pokerout_Respone;
class pokerout_ResponeDefaultTypeInternal;
extern pokerout_ResponeDefaultTypeInternal _pokerout_Respone_default_instance_;
class room_createReq;
class room_createReqDefaultTypeInternal;
extern room_createReqDefaultTypeInternal _room_createReq_default_instance_;
class room_createRespone;
class room_createResponeDefaultTypeInternal;
extern room_createResponeDefaultTypeInternal _room_createRespone_default_instance_;
class room_gamestartRespone;
class room_gamestartResponeDefaultTypeInternal;
extern room_gamestartResponeDefaultTypeInternal _room_gamestartRespone_default_instance_;
class room_joinReq;
class room_joinReqDefaultTypeInternal;
extern room_joinReqDefaultTypeInternal _room_joinReq_default_instance_;
class room_joinRespone;
class room_joinResponeDefaultTypeInternal;
extern room_joinResponeDefaultTypeInternal _room_joinRespone_default_instance_;
class room_playerReady;
class room_playerReadyDefaultTypeInternal;
extern room_playerReadyDefaultTypeInternal _room_playerReady_default_instance_;
class room_playerReadyRespone;
class room_playerReadyResponeDefaultTypeInternal;
extern room_playerReadyResponeDefaultTypeInternal _room_playerReadyRespone_default_instance_;
}  // namespace ccg_pb
namespace ccg_pb {

// ===================================================================

class PlayerData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.PlayerData) */ {
 public:
  PlayerData();
  virtual ~PlayerData();

  PlayerData(const PlayerData& from);

  inline PlayerData& operator=(const PlayerData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerData(PlayerData&& from) noexcept
    : PlayerData() {
    *this = ::std::move(from);
  }

  inline PlayerData& operator=(PlayerData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerData* internal_default_instance() {
    return reinterpret_cast<const PlayerData*>(
               &_PlayerData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PlayerData* other);
  friend void swap(PlayerData& a, PlayerData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerData* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerData& from);
  void MergeFrom(const PlayerData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nick = 2;
  bool has_nick() const;
  void clear_nick();
  static const int kNickFieldNumber = 2;
  const ::std::string& nick() const;
  void set_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_nick(::std::string&& value);
  #endif
  void set_nick(const char* value);
  void set_nick(const char* value, size_t size);
  ::std::string* mutable_nick();
  ::std::string* release_nick();
  void set_allocated_nick(::std::string* nick);

  // required string headurl = 3;
  bool has_headurl() const;
  void clear_headurl();
  static const int kHeadurlFieldNumber = 3;
  const ::std::string& headurl() const;
  void set_headurl(const ::std::string& value);
  #if LANG_CXX11
  void set_headurl(::std::string&& value);
  #endif
  void set_headurl(const char* value);
  void set_headurl(const char* value, size_t size);
  ::std::string* mutable_headurl();
  ::std::string* release_headurl();
  void set_allocated_headurl(::std::string* headurl);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 status = 4;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.PlayerData)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_nick();
  void clear_has_nick();
  void set_has_headurl();
  void clear_has_headurl();
  void set_has_status();
  void clear_has_status();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::google::protobuf::internal::ArenaStringPtr headurl_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 status_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsPlayerDataImpl();
};
// -------------------------------------------------------------------

class login_namepasswordReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.login_namepasswordReq) */ {
 public:
  login_namepasswordReq();
  virtual ~login_namepasswordReq();

  login_namepasswordReq(const login_namepasswordReq& from);

  inline login_namepasswordReq& operator=(const login_namepasswordReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  login_namepasswordReq(login_namepasswordReq&& from) noexcept
    : login_namepasswordReq() {
    *this = ::std::move(from);
  }

  inline login_namepasswordReq& operator=(login_namepasswordReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login_namepasswordReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const login_namepasswordReq* internal_default_instance() {
    return reinterpret_cast<const login_namepasswordReq*>(
               &_login_namepasswordReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(login_namepasswordReq* other);
  friend void swap(login_namepasswordReq& a, login_namepasswordReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline login_namepasswordReq* New() const PROTOBUF_FINAL { return New(NULL); }

  login_namepasswordReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const login_namepasswordReq& from);
  void MergeFrom(const login_namepasswordReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(login_namepasswordReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required int32 DeviceType = 3;
  bool has_devicetype() const;
  void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 3;
  ::google::protobuf::int32 devicetype() const;
  void set_devicetype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.login_namepasswordReq)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_password();
  void clear_has_password();
  void set_has_devicetype();
  void clear_has_devicetype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::int32 devicetype_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultslogin_namepasswordReqImpl();
};
// -------------------------------------------------------------------

class login_DeviceReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.login_DeviceReq) */ {
 public:
  login_DeviceReq();
  virtual ~login_DeviceReq();

  login_DeviceReq(const login_DeviceReq& from);

  inline login_DeviceReq& operator=(const login_DeviceReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  login_DeviceReq(login_DeviceReq&& from) noexcept
    : login_DeviceReq() {
    *this = ::std::move(from);
  }

  inline login_DeviceReq& operator=(login_DeviceReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login_DeviceReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const login_DeviceReq* internal_default_instance() {
    return reinterpret_cast<const login_DeviceReq*>(
               &_login_DeviceReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(login_DeviceReq* other);
  friend void swap(login_DeviceReq& a, login_DeviceReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline login_DeviceReq* New() const PROTOBUF_FINAL { return New(NULL); }

  login_DeviceReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const login_DeviceReq& from);
  void MergeFrom(const login_DeviceReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(login_DeviceReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string udid = 1;
  bool has_udid() const;
  void clear_udid();
  static const int kUdidFieldNumber = 1;
  const ::std::string& udid() const;
  void set_udid(const ::std::string& value);
  #if LANG_CXX11
  void set_udid(::std::string&& value);
  #endif
  void set_udid(const char* value);
  void set_udid(const char* value, size_t size);
  ::std::string* mutable_udid();
  ::std::string* release_udid();
  void set_allocated_udid(::std::string* udid);

  // required int32 DeviceType = 2;
  bool has_devicetype() const;
  void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 2;
  ::google::protobuf::int32 devicetype() const;
  void set_devicetype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.login_DeviceReq)
 private:
  void set_has_udid();
  void clear_has_udid();
  void set_has_devicetype();
  void clear_has_devicetype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr udid_;
  ::google::protobuf::int32 devicetype_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultslogin_DeviceReqImpl();
};
// -------------------------------------------------------------------

class login_wechatReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.login_wechatReq) */ {
 public:
  login_wechatReq();
  virtual ~login_wechatReq();

  login_wechatReq(const login_wechatReq& from);

  inline login_wechatReq& operator=(const login_wechatReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  login_wechatReq(login_wechatReq&& from) noexcept
    : login_wechatReq() {
    *this = ::std::move(from);
  }

  inline login_wechatReq& operator=(login_wechatReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login_wechatReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const login_wechatReq* internal_default_instance() {
    return reinterpret_cast<const login_wechatReq*>(
               &_login_wechatReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(login_wechatReq* other);
  friend void swap(login_wechatReq& a, login_wechatReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline login_wechatReq* New() const PROTOBUF_FINAL { return New(NULL); }

  login_wechatReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const login_wechatReq& from);
  void MergeFrom(const login_wechatReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(login_wechatReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string udid = 1;
  bool has_udid() const;
  void clear_udid();
  static const int kUdidFieldNumber = 1;
  const ::std::string& udid() const;
  void set_udid(const ::std::string& value);
  #if LANG_CXX11
  void set_udid(::std::string&& value);
  #endif
  void set_udid(const char* value);
  void set_udid(const char* value, size_t size);
  ::std::string* mutable_udid();
  ::std::string* release_udid();
  void set_allocated_udid(::std::string* udid);

  // required string headurl = 3;
  bool has_headurl() const;
  void clear_headurl();
  static const int kHeadurlFieldNumber = 3;
  const ::std::string& headurl() const;
  void set_headurl(const ::std::string& value);
  #if LANG_CXX11
  void set_headurl(::std::string&& value);
  #endif
  void set_headurl(const char* value);
  void set_headurl(const char* value, size_t size);
  ::std::string* mutable_headurl();
  ::std::string* release_headurl();
  void set_allocated_headurl(::std::string* headurl);

  // required int32 DeviceType = 2;
  bool has_devicetype() const;
  void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 2;
  ::google::protobuf::int32 devicetype() const;
  void set_devicetype(::google::protobuf::int32 value);

  // required int32 type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.login_wechatReq)
 private:
  void set_has_udid();
  void clear_has_udid();
  void set_has_devicetype();
  void clear_has_devicetype();
  void set_has_headurl();
  void clear_has_headurl();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr udid_;
  ::google::protobuf::internal::ArenaStringPtr headurl_;
  ::google::protobuf::int32 devicetype_;
  ::google::protobuf::int32 type_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultslogin_wechatReqImpl();
};
// -------------------------------------------------------------------

class login_Respone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.login_Respone) */ {
 public:
  login_Respone();
  virtual ~login_Respone();

  login_Respone(const login_Respone& from);

  inline login_Respone& operator=(const login_Respone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  login_Respone(login_Respone&& from) noexcept
    : login_Respone() {
    *this = ::std::move(from);
  }

  inline login_Respone& operator=(login_Respone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login_Respone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const login_Respone* internal_default_instance() {
    return reinterpret_cast<const login_Respone*>(
               &_login_Respone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(login_Respone* other);
  friend void swap(login_Respone& a, login_Respone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline login_Respone* New() const PROTOBUF_FINAL { return New(NULL); }

  login_Respone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const login_Respone& from);
  void MergeFrom(const login_Respone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(login_Respone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nick = 2;
  bool has_nick() const;
  void clear_nick();
  static const int kNickFieldNumber = 2;
  const ::std::string& nick() const;
  void set_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_nick(::std::string&& value);
  #endif
  void set_nick(const char* value);
  void set_nick(const char* value, size_t size);
  ::std::string* mutable_nick();
  ::std::string* release_nick();
  void set_allocated_nick(::std::string* nick);

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // required int32 id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.login_Respone)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_nick();
  void clear_has_nick();
  void set_has_id();
  void clear_has_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultslogin_ResponeImpl();
};
// -------------------------------------------------------------------

class room_createReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.room_createReq) */ {
 public:
  room_createReq();
  virtual ~room_createReq();

  room_createReq(const room_createReq& from);

  inline room_createReq& operator=(const room_createReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  room_createReq(room_createReq&& from) noexcept
    : room_createReq() {
    *this = ::std::move(from);
  }

  inline room_createReq& operator=(room_createReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const room_createReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const room_createReq* internal_default_instance() {
    return reinterpret_cast<const room_createReq*>(
               &_room_createReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(room_createReq* other);
  friend void swap(room_createReq& a, room_createReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline room_createReq* New() const PROTOBUF_FINAL { return New(NULL); }

  room_createReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const room_createReq& from);
  void MergeFrom(const room_createReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(room_createReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 roomtype = 2;
  bool has_roomtype() const;
  void clear_roomtype();
  static const int kRoomtypeFieldNumber = 2;
  ::google::protobuf::int32 roomtype() const;
  void set_roomtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.room_createReq)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_roomtype();
  void clear_has_roomtype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 roomtype_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsroom_createReqImpl();
};
// -------------------------------------------------------------------

class room_createRespone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.room_createRespone) */ {
 public:
  room_createRespone();
  virtual ~room_createRespone();

  room_createRespone(const room_createRespone& from);

  inline room_createRespone& operator=(const room_createRespone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  room_createRespone(room_createRespone&& from) noexcept
    : room_createRespone() {
    *this = ::std::move(from);
  }

  inline room_createRespone& operator=(room_createRespone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const room_createRespone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const room_createRespone* internal_default_instance() {
    return reinterpret_cast<const room_createRespone*>(
               &_room_createRespone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(room_createRespone* other);
  friend void swap(room_createRespone& a, room_createRespone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline room_createRespone* New() const PROTOBUF_FINAL { return New(NULL); }

  room_createRespone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const room_createRespone& from);
  void MergeFrom(const room_createRespone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(room_createRespone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorcode = 1;
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorcodeFieldNumber = 1;
  ::google::protobuf::int32 errorcode() const;
  void set_errorcode(::google::protobuf::int32 value);

  // required int32 roomid = 2;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomidFieldNumber = 2;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.room_createRespone)
 private:
  void set_has_errorcode();
  void clear_has_errorcode();
  void set_has_roomid();
  void clear_has_roomid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 errorcode_;
  ::google::protobuf::int32 roomid_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsroom_createResponeImpl();
};
// -------------------------------------------------------------------

class room_joinReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.room_joinReq) */ {
 public:
  room_joinReq();
  virtual ~room_joinReq();

  room_joinReq(const room_joinReq& from);

  inline room_joinReq& operator=(const room_joinReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  room_joinReq(room_joinReq&& from) noexcept
    : room_joinReq() {
    *this = ::std::move(from);
  }

  inline room_joinReq& operator=(room_joinReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const room_joinReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const room_joinReq* internal_default_instance() {
    return reinterpret_cast<const room_joinReq*>(
               &_room_joinReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(room_joinReq* other);
  friend void swap(room_joinReq& a, room_joinReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline room_joinReq* New() const PROTOBUF_FINAL { return New(NULL); }

  room_joinReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const room_joinReq& from);
  void MergeFrom(const room_joinReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(room_joinReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 roomid = 2;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomidFieldNumber = 2;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.room_joinReq)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_roomid();
  void clear_has_roomid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 roomid_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsroom_joinReqImpl();
};
// -------------------------------------------------------------------

class room_joinRespone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.room_joinRespone) */ {
 public:
  room_joinRespone();
  virtual ~room_joinRespone();

  room_joinRespone(const room_joinRespone& from);

  inline room_joinRespone& operator=(const room_joinRespone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  room_joinRespone(room_joinRespone&& from) noexcept
    : room_joinRespone() {
    *this = ::std::move(from);
  }

  inline room_joinRespone& operator=(room_joinRespone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const room_joinRespone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const room_joinRespone* internal_default_instance() {
    return reinterpret_cast<const room_joinRespone*>(
               &_room_joinRespone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(room_joinRespone* other);
  friend void swap(room_joinRespone& a, room_joinRespone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline room_joinRespone* New() const PROTOBUF_FINAL { return New(NULL); }

  room_joinRespone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const room_joinRespone& from);
  void MergeFrom(const room_joinRespone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(room_joinRespone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ccg_pb.PlayerData pd = 2;
  int pd_size() const;
  void clear_pd();
  static const int kPdFieldNumber = 2;
  const ::ccg_pb::PlayerData& pd(int index) const;
  ::ccg_pb::PlayerData* mutable_pd(int index);
  ::ccg_pb::PlayerData* add_pd();
  ::google::protobuf::RepeatedPtrField< ::ccg_pb::PlayerData >*
      mutable_pd();
  const ::google::protobuf::RepeatedPtrField< ::ccg_pb::PlayerData >&
      pd() const;

  // required int32 errorcode = 1;
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorcodeFieldNumber = 1;
  ::google::protobuf::int32 errorcode() const;
  void set_errorcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.room_joinRespone)
 private:
  void set_has_errorcode();
  void clear_has_errorcode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ccg_pb::PlayerData > pd_;
  ::google::protobuf::int32 errorcode_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsroom_joinResponeImpl();
};
// -------------------------------------------------------------------

class room_playerReady : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.room_playerReady) */ {
 public:
  room_playerReady();
  virtual ~room_playerReady();

  room_playerReady(const room_playerReady& from);

  inline room_playerReady& operator=(const room_playerReady& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  room_playerReady(room_playerReady&& from) noexcept
    : room_playerReady() {
    *this = ::std::move(from);
  }

  inline room_playerReady& operator=(room_playerReady&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const room_playerReady& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const room_playerReady* internal_default_instance() {
    return reinterpret_cast<const room_playerReady*>(
               &_room_playerReady_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(room_playerReady* other);
  friend void swap(room_playerReady& a, room_playerReady& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline room_playerReady* New() const PROTOBUF_FINAL { return New(NULL); }

  room_playerReady* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const room_playerReady& from);
  void MergeFrom(const room_playerReady& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(room_playerReady* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.room_playerReady)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsroom_playerReadyImpl();
};
// -------------------------------------------------------------------

class room_playerReadyRespone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.room_playerReadyRespone) */ {
 public:
  room_playerReadyRespone();
  virtual ~room_playerReadyRespone();

  room_playerReadyRespone(const room_playerReadyRespone& from);

  inline room_playerReadyRespone& operator=(const room_playerReadyRespone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  room_playerReadyRespone(room_playerReadyRespone&& from) noexcept
    : room_playerReadyRespone() {
    *this = ::std::move(from);
  }

  inline room_playerReadyRespone& operator=(room_playerReadyRespone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const room_playerReadyRespone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const room_playerReadyRespone* internal_default_instance() {
    return reinterpret_cast<const room_playerReadyRespone*>(
               &_room_playerReadyRespone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(room_playerReadyRespone* other);
  friend void swap(room_playerReadyRespone& a, room_playerReadyRespone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline room_playerReadyRespone* New() const PROTOBUF_FINAL { return New(NULL); }

  room_playerReadyRespone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const room_playerReadyRespone& from);
  void MergeFrom(const room_playerReadyRespone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(room_playerReadyRespone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.room_playerReadyRespone)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsroom_playerReadyResponeImpl();
};
// -------------------------------------------------------------------

class room_gamestartRespone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.room_gamestartRespone) */ {
 public:
  room_gamestartRespone();
  virtual ~room_gamestartRespone();

  room_gamestartRespone(const room_gamestartRespone& from);

  inline room_gamestartRespone& operator=(const room_gamestartRespone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  room_gamestartRespone(room_gamestartRespone&& from) noexcept
    : room_gamestartRespone() {
    *this = ::std::move(from);
  }

  inline room_gamestartRespone& operator=(room_gamestartRespone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const room_gamestartRespone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const room_gamestartRespone* internal_default_instance() {
    return reinterpret_cast<const room_gamestartRespone*>(
               &_room_gamestartRespone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(room_gamestartRespone* other);
  friend void swap(room_gamestartRespone& a, room_gamestartRespone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline room_gamestartRespone* New() const PROTOBUF_FINAL { return New(NULL); }

  room_gamestartRespone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const room_gamestartRespone& from);
  void MergeFrom(const room_gamestartRespone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(room_gamestartRespone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ccg_pb.poker pk = 2;
  int pk_size() const;
  void clear_pk();
  static const int kPkFieldNumber = 2;
  const ::ccg_pb::poker& pk(int index) const;
  ::ccg_pb::poker* mutable_pk(int index);
  ::ccg_pb::poker* add_pk();
  ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker >*
      mutable_pk();
  const ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker >&
      pk() const;

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.room_gamestartRespone)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker > pk_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsroom_gamestartResponeImpl();
};
// -------------------------------------------------------------------

class poker : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.poker) */ {
 public:
  poker();
  virtual ~poker();

  poker(const poker& from);

  inline poker& operator=(const poker& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  poker(poker&& from) noexcept
    : poker() {
    *this = ::std::move(from);
  }

  inline poker& operator=(poker&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const poker& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const poker* internal_default_instance() {
    return reinterpret_cast<const poker*>(
               &_poker_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(poker* other);
  friend void swap(poker& a, poker& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline poker* New() const PROTOBUF_FINAL { return New(NULL); }

  poker* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const poker& from);
  void MergeFrom(const poker& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(poker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.poker)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultspokerImpl();
};
// -------------------------------------------------------------------

class call : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.call) */ {
 public:
  call();
  virtual ~call();

  call(const call& from);

  inline call& operator=(const call& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  call(call&& from) noexcept
    : call() {
    *this = ::std::move(from);
  }

  inline call& operator=(call&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const call& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const call* internal_default_instance() {
    return reinterpret_cast<const call*>(
               &_call_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(call* other);
  friend void swap(call& a, call& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline call* New() const PROTOBUF_FINAL { return New(NULL); }

  call* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const call& from);
  void MergeFrom(const call& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(call* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 num = 2;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 2;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.call)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_num();
  void clear_has_num();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 num_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultscallImpl();
};
// -------------------------------------------------------------------

class call_Respone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.call_Respone) */ {
 public:
  call_Respone();
  virtual ~call_Respone();

  call_Respone(const call_Respone& from);

  inline call_Respone& operator=(const call_Respone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  call_Respone(call_Respone&& from) noexcept
    : call_Respone() {
    *this = ::std::move(from);
  }

  inline call_Respone& operator=(call_Respone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const call_Respone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const call_Respone* internal_default_instance() {
    return reinterpret_cast<const call_Respone*>(
               &_call_Respone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(call_Respone* other);
  friend void swap(call_Respone& a, call_Respone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline call_Respone* New() const PROTOBUF_FINAL { return New(NULL); }

  call_Respone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const call_Respone& from);
  void MergeFrom(const call_Respone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(call_Respone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 num = 2;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 2;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // required int32 nextcallid = 3;
  bool has_nextcallid() const;
  void clear_nextcallid();
  static const int kNextcallidFieldNumber = 3;
  ::google::protobuf::int32 nextcallid() const;
  void set_nextcallid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.call_Respone)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_num();
  void clear_has_num();
  void set_has_nextcallid();
  void clear_has_nextcallid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 nextcallid_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultscall_ResponeImpl();
};
// -------------------------------------------------------------------

class call_begin_Respone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.call_begin_Respone) */ {
 public:
  call_begin_Respone();
  virtual ~call_begin_Respone();

  call_begin_Respone(const call_begin_Respone& from);

  inline call_begin_Respone& operator=(const call_begin_Respone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  call_begin_Respone(call_begin_Respone&& from) noexcept
    : call_begin_Respone() {
    *this = ::std::move(from);
  }

  inline call_begin_Respone& operator=(call_begin_Respone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const call_begin_Respone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const call_begin_Respone* internal_default_instance() {
    return reinterpret_cast<const call_begin_Respone*>(
               &_call_begin_Respone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(call_begin_Respone* other);
  friend void swap(call_begin_Respone& a, call_begin_Respone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline call_begin_Respone* New() const PROTOBUF_FINAL { return New(NULL); }

  call_begin_Respone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const call_begin_Respone& from);
  void MergeFrom(const call_begin_Respone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(call_begin_Respone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 num = 2;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 2;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.call_begin_Respone)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_num();
  void clear_has_num();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 num_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultscall_begin_ResponeImpl();
};
// -------------------------------------------------------------------

class pokerout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.pokerout) */ {
 public:
  pokerout();
  virtual ~pokerout();

  pokerout(const pokerout& from);

  inline pokerout& operator=(const pokerout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  pokerout(pokerout&& from) noexcept
    : pokerout() {
    *this = ::std::move(from);
  }

  inline pokerout& operator=(pokerout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pokerout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const pokerout* internal_default_instance() {
    return reinterpret_cast<const pokerout*>(
               &_pokerout_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(pokerout* other);
  friend void swap(pokerout& a, pokerout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline pokerout* New() const PROTOBUF_FINAL { return New(NULL); }

  pokerout* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const pokerout& from);
  void MergeFrom(const pokerout& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(pokerout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ccg_pb.poker pk = 2;
  int pk_size() const;
  void clear_pk();
  static const int kPkFieldNumber = 2;
  const ::ccg_pb::poker& pk(int index) const;
  ::ccg_pb::poker* mutable_pk(int index);
  ::ccg_pb::poker* add_pk();
  ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker >*
      mutable_pk();
  const ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker >&
      pk() const;

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.pokerout)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker > pk_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultspokeroutImpl();
};
// -------------------------------------------------------------------

class pokerout_Respone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.pokerout_Respone) */ {
 public:
  pokerout_Respone();
  virtual ~pokerout_Respone();

  pokerout_Respone(const pokerout_Respone& from);

  inline pokerout_Respone& operator=(const pokerout_Respone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  pokerout_Respone(pokerout_Respone&& from) noexcept
    : pokerout_Respone() {
    *this = ::std::move(from);
  }

  inline pokerout_Respone& operator=(pokerout_Respone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pokerout_Respone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const pokerout_Respone* internal_default_instance() {
    return reinterpret_cast<const pokerout_Respone*>(
               &_pokerout_Respone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(pokerout_Respone* other);
  friend void swap(pokerout_Respone& a, pokerout_Respone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline pokerout_Respone* New() const PROTOBUF_FINAL { return New(NULL); }

  pokerout_Respone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const pokerout_Respone& from);
  void MergeFrom(const pokerout_Respone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(pokerout_Respone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ccg_pb.poker pk = 2;
  int pk_size() const;
  void clear_pk();
  static const int kPkFieldNumber = 2;
  const ::ccg_pb::poker& pk(int index) const;
  ::ccg_pb::poker* mutable_pk(int index);
  ::ccg_pb::poker* add_pk();
  ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker >*
      mutable_pk();
  const ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker >&
      pk() const;

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 nextid = 3;
  bool has_nextid() const;
  void clear_nextid();
  static const int kNextidFieldNumber = 3;
  ::google::protobuf::int32 nextid() const;
  void set_nextid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.pokerout_Respone)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_nextid();
  void clear_has_nextid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker > pk_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 nextid_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultspokerout_ResponeImpl();
};
// -------------------------------------------------------------------

class gameend_Respone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.gameend_Respone) */ {
 public:
  gameend_Respone();
  virtual ~gameend_Respone();

  gameend_Respone(const gameend_Respone& from);

  inline gameend_Respone& operator=(const gameend_Respone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  gameend_Respone(gameend_Respone&& from) noexcept
    : gameend_Respone() {
    *this = ::std::move(from);
  }

  inline gameend_Respone& operator=(gameend_Respone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gameend_Respone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const gameend_Respone* internal_default_instance() {
    return reinterpret_cast<const gameend_Respone*>(
               &_gameend_Respone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(gameend_Respone* other);
  friend void swap(gameend_Respone& a, gameend_Respone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline gameend_Respone* New() const PROTOBUF_FINAL { return New(NULL); }

  gameend_Respone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const gameend_Respone& from);
  void MergeFrom(const gameend_Respone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(gameend_Respone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ccg_pb.gameend_Respone)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsgameend_ResponeImpl();
};
// -------------------------------------------------------------------

class chattext : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.chattext) */ {
 public:
  chattext();
  virtual ~chattext();

  chattext(const chattext& from);

  inline chattext& operator=(const chattext& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  chattext(chattext&& from) noexcept
    : chattext() {
    *this = ::std::move(from);
  }

  inline chattext& operator=(chattext&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chattext& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const chattext* internal_default_instance() {
    return reinterpret_cast<const chattext*>(
               &_chattext_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(chattext* other);
  friend void swap(chattext& a, chattext& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline chattext* New() const PROTOBUF_FINAL { return New(NULL); }

  chattext* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const chattext& from);
  void MergeFrom(const chattext& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(chattext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 textid = 2;
  bool has_textid() const;
  void clear_textid();
  static const int kTextidFieldNumber = 2;
  ::google::protobuf::int32 textid() const;
  void set_textid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.chattext)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_textid();
  void clear_has_textid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 textid_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultschattextImpl();
};
// -------------------------------------------------------------------

class chatemo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.chatemo) */ {
 public:
  chatemo();
  virtual ~chatemo();

  chatemo(const chatemo& from);

  inline chatemo& operator=(const chatemo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  chatemo(chatemo&& from) noexcept
    : chatemo() {
    *this = ::std::move(from);
  }

  inline chatemo& operator=(chatemo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chatemo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const chatemo* internal_default_instance() {
    return reinterpret_cast<const chatemo*>(
               &_chatemo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(chatemo* other);
  friend void swap(chatemo& a, chatemo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline chatemo* New() const PROTOBUF_FINAL { return New(NULL); }

  chatemo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const chatemo& from);
  void MergeFrom(const chatemo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(chatemo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 emoid = 2;
  bool has_emoid() const;
  void clear_emoid();
  static const int kEmoidFieldNumber = 2;
  ::google::protobuf::int32 emoid() const;
  void set_emoid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.chatemo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_emoid();
  void clear_has_emoid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 emoid_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultschatemoImpl();
};
// -------------------------------------------------------------------

class chatstring : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.chatstring) */ {
 public:
  chatstring();
  virtual ~chatstring();

  chatstring(const chatstring& from);

  inline chatstring& operator=(const chatstring& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  chatstring(chatstring&& from) noexcept
    : chatstring() {
    *this = ::std::move(from);
  }

  inline chatstring& operator=(chatstring&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chatstring& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const chatstring* internal_default_instance() {
    return reinterpret_cast<const chatstring*>(
               &_chatstring_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(chatstring* other);
  friend void swap(chatstring& a, chatstring& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline chatstring* New() const PROTOBUF_FINAL { return New(NULL); }

  chatstring* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const chatstring& from);
  void MergeFrom(const chatstring& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(chatstring* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 2;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 2;
  const ::std::string& str() const;
  void set_str(const ::std::string& value);
  #if LANG_CXX11
  void set_str(::std::string&& value);
  #endif
  void set_str(const char* value);
  void set_str(const char* value, size_t size);
  ::std::string* mutable_str();
  ::std::string* release_str();
  void set_allocated_str(::std::string* str);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.chatstring)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_str();
  void clear_has_str();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr str_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultschatstringImpl();
};
// -------------------------------------------------------------------

class chattext_Respone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.chattext_Respone) */ {
 public:
  chattext_Respone();
  virtual ~chattext_Respone();

  chattext_Respone(const chattext_Respone& from);

  inline chattext_Respone& operator=(const chattext_Respone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  chattext_Respone(chattext_Respone&& from) noexcept
    : chattext_Respone() {
    *this = ::std::move(from);
  }

  inline chattext_Respone& operator=(chattext_Respone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chattext_Respone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const chattext_Respone* internal_default_instance() {
    return reinterpret_cast<const chattext_Respone*>(
               &_chattext_Respone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(chattext_Respone* other);
  friend void swap(chattext_Respone& a, chattext_Respone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline chattext_Respone* New() const PROTOBUF_FINAL { return New(NULL); }

  chattext_Respone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const chattext_Respone& from);
  void MergeFrom(const chattext_Respone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(chattext_Respone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 textid = 2;
  bool has_textid() const;
  void clear_textid();
  static const int kTextidFieldNumber = 2;
  ::google::protobuf::int32 textid() const;
  void set_textid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.chattext_Respone)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_textid();
  void clear_has_textid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 textid_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultschattext_ResponeImpl();
};
// -------------------------------------------------------------------

class chatemo_Respone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.chatemo_Respone) */ {
 public:
  chatemo_Respone();
  virtual ~chatemo_Respone();

  chatemo_Respone(const chatemo_Respone& from);

  inline chatemo_Respone& operator=(const chatemo_Respone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  chatemo_Respone(chatemo_Respone&& from) noexcept
    : chatemo_Respone() {
    *this = ::std::move(from);
  }

  inline chatemo_Respone& operator=(chatemo_Respone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chatemo_Respone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const chatemo_Respone* internal_default_instance() {
    return reinterpret_cast<const chatemo_Respone*>(
               &_chatemo_Respone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(chatemo_Respone* other);
  friend void swap(chatemo_Respone& a, chatemo_Respone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline chatemo_Respone* New() const PROTOBUF_FINAL { return New(NULL); }

  chatemo_Respone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const chatemo_Respone& from);
  void MergeFrom(const chatemo_Respone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(chatemo_Respone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 emoid = 2;
  bool has_emoid() const;
  void clear_emoid();
  static const int kEmoidFieldNumber = 2;
  ::google::protobuf::int32 emoid() const;
  void set_emoid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.chatemo_Respone)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_emoid();
  void clear_has_emoid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 emoid_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultschatemo_ResponeImpl();
};
// -------------------------------------------------------------------

class chatstring_Respone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ccg_pb.chatstring_Respone) */ {
 public:
  chatstring_Respone();
  virtual ~chatstring_Respone();

  chatstring_Respone(const chatstring_Respone& from);

  inline chatstring_Respone& operator=(const chatstring_Respone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  chatstring_Respone(chatstring_Respone&& from) noexcept
    : chatstring_Respone() {
    *this = ::std::move(from);
  }

  inline chatstring_Respone& operator=(chatstring_Respone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chatstring_Respone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const chatstring_Respone* internal_default_instance() {
    return reinterpret_cast<const chatstring_Respone*>(
               &_chatstring_Respone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(chatstring_Respone* other);
  friend void swap(chatstring_Respone& a, chatstring_Respone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline chatstring_Respone* New() const PROTOBUF_FINAL { return New(NULL); }

  chatstring_Respone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const chatstring_Respone& from);
  void MergeFrom(const chatstring_Respone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(chatstring_Respone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 2;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 2;
  const ::std::string& str() const;
  void set_str(const ::std::string& value);
  #if LANG_CXX11
  void set_str(::std::string&& value);
  #endif
  void set_str(const char* value);
  void set_str(const char* value, size_t size);
  ::std::string* mutable_str();
  ::std::string* release_str();
  void set_allocated_str(::std::string* str);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ccg_pb.chatstring_Respone)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_str();
  void clear_has_str();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr str_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultschatstring_ResponeImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerData

// required int32 id = 1;
inline bool PlayerData::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerData::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerData::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 PlayerData::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.PlayerData.id)
  return id_;
}
inline void PlayerData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.PlayerData.id)
}

// required string nick = 2;
inline bool PlayerData::has_nick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerData::set_has_nick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerData::clear_has_nick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerData::clear_nick() {
  nick_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nick();
}
inline const ::std::string& PlayerData::nick() const {
  // @@protoc_insertion_point(field_get:ccg_pb.PlayerData.nick)
  return nick_.GetNoArena();
}
inline void PlayerData::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ccg_pb.PlayerData.nick)
}
#if LANG_CXX11
inline void PlayerData::set_nick(::std::string&& value) {
  set_has_nick();
  nick_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ccg_pb.PlayerData.nick)
}
#endif
inline void PlayerData::set_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ccg_pb.PlayerData.nick)
}
inline void PlayerData::set_nick(const char* value, size_t size) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ccg_pb.PlayerData.nick)
}
inline ::std::string* PlayerData::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:ccg_pb.PlayerData.nick)
  return nick_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerData::release_nick() {
  // @@protoc_insertion_point(field_release:ccg_pb.PlayerData.nick)
  clear_has_nick();
  return nick_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerData::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick);
  // @@protoc_insertion_point(field_set_allocated:ccg_pb.PlayerData.nick)
}

// required string headurl = 3;
inline bool PlayerData::has_headurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerData::set_has_headurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerData::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerData::clear_headurl() {
  headurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_headurl();
}
inline const ::std::string& PlayerData::headurl() const {
  // @@protoc_insertion_point(field_get:ccg_pb.PlayerData.headurl)
  return headurl_.GetNoArena();
}
inline void PlayerData::set_headurl(const ::std::string& value) {
  set_has_headurl();
  headurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ccg_pb.PlayerData.headurl)
}
#if LANG_CXX11
inline void PlayerData::set_headurl(::std::string&& value) {
  set_has_headurl();
  headurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ccg_pb.PlayerData.headurl)
}
#endif
inline void PlayerData::set_headurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_headurl();
  headurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ccg_pb.PlayerData.headurl)
}
inline void PlayerData::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  headurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ccg_pb.PlayerData.headurl)
}
inline ::std::string* PlayerData::mutable_headurl() {
  set_has_headurl();
  // @@protoc_insertion_point(field_mutable:ccg_pb.PlayerData.headurl)
  return headurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerData::release_headurl() {
  // @@protoc_insertion_point(field_release:ccg_pb.PlayerData.headurl)
  clear_has_headurl();
  return headurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerData::set_allocated_headurl(::std::string* headurl) {
  if (headurl != NULL) {
    set_has_headurl();
  } else {
    clear_has_headurl();
  }
  headurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), headurl);
  // @@protoc_insertion_point(field_set_allocated:ccg_pb.PlayerData.headurl)
}

// required int32 status = 4;
inline bool PlayerData::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerData::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerData::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerData::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 PlayerData::status() const {
  // @@protoc_insertion_point(field_get:ccg_pb.PlayerData.status)
  return status_;
}
inline void PlayerData::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.PlayerData.status)
}

// -------------------------------------------------------------------

// login_namepasswordReq

// required string name = 1;
inline bool login_namepasswordReq::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login_namepasswordReq::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login_namepasswordReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login_namepasswordReq::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& login_namepasswordReq::name() const {
  // @@protoc_insertion_point(field_get:ccg_pb.login_namepasswordReq.name)
  return name_.GetNoArena();
}
inline void login_namepasswordReq::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ccg_pb.login_namepasswordReq.name)
}
#if LANG_CXX11
inline void login_namepasswordReq::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ccg_pb.login_namepasswordReq.name)
}
#endif
inline void login_namepasswordReq::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ccg_pb.login_namepasswordReq.name)
}
inline void login_namepasswordReq::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ccg_pb.login_namepasswordReq.name)
}
inline ::std::string* login_namepasswordReq::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ccg_pb.login_namepasswordReq.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* login_namepasswordReq::release_name() {
  // @@protoc_insertion_point(field_release:ccg_pb.login_namepasswordReq.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void login_namepasswordReq::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ccg_pb.login_namepasswordReq.name)
}

// required string password = 2;
inline bool login_namepasswordReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login_namepasswordReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login_namepasswordReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login_namepasswordReq::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& login_namepasswordReq::password() const {
  // @@protoc_insertion_point(field_get:ccg_pb.login_namepasswordReq.password)
  return password_.GetNoArena();
}
inline void login_namepasswordReq::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ccg_pb.login_namepasswordReq.password)
}
#if LANG_CXX11
inline void login_namepasswordReq::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ccg_pb.login_namepasswordReq.password)
}
#endif
inline void login_namepasswordReq::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ccg_pb.login_namepasswordReq.password)
}
inline void login_namepasswordReq::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ccg_pb.login_namepasswordReq.password)
}
inline ::std::string* login_namepasswordReq::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:ccg_pb.login_namepasswordReq.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* login_namepasswordReq::release_password() {
  // @@protoc_insertion_point(field_release:ccg_pb.login_namepasswordReq.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void login_namepasswordReq::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:ccg_pb.login_namepasswordReq.password)
}

// required int32 DeviceType = 3;
inline bool login_namepasswordReq::has_devicetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void login_namepasswordReq::set_has_devicetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void login_namepasswordReq::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void login_namepasswordReq::clear_devicetype() {
  devicetype_ = 0;
  clear_has_devicetype();
}
inline ::google::protobuf::int32 login_namepasswordReq::devicetype() const {
  // @@protoc_insertion_point(field_get:ccg_pb.login_namepasswordReq.DeviceType)
  return devicetype_;
}
inline void login_namepasswordReq::set_devicetype(::google::protobuf::int32 value) {
  set_has_devicetype();
  devicetype_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.login_namepasswordReq.DeviceType)
}

// -------------------------------------------------------------------

// login_DeviceReq

// required string udid = 1;
inline bool login_DeviceReq::has_udid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login_DeviceReq::set_has_udid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login_DeviceReq::clear_has_udid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login_DeviceReq::clear_udid() {
  udid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_udid();
}
inline const ::std::string& login_DeviceReq::udid() const {
  // @@protoc_insertion_point(field_get:ccg_pb.login_DeviceReq.udid)
  return udid_.GetNoArena();
}
inline void login_DeviceReq::set_udid(const ::std::string& value) {
  set_has_udid();
  udid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ccg_pb.login_DeviceReq.udid)
}
#if LANG_CXX11
inline void login_DeviceReq::set_udid(::std::string&& value) {
  set_has_udid();
  udid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ccg_pb.login_DeviceReq.udid)
}
#endif
inline void login_DeviceReq::set_udid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_udid();
  udid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ccg_pb.login_DeviceReq.udid)
}
inline void login_DeviceReq::set_udid(const char* value, size_t size) {
  set_has_udid();
  udid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ccg_pb.login_DeviceReq.udid)
}
inline ::std::string* login_DeviceReq::mutable_udid() {
  set_has_udid();
  // @@protoc_insertion_point(field_mutable:ccg_pb.login_DeviceReq.udid)
  return udid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* login_DeviceReq::release_udid() {
  // @@protoc_insertion_point(field_release:ccg_pb.login_DeviceReq.udid)
  clear_has_udid();
  return udid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void login_DeviceReq::set_allocated_udid(::std::string* udid) {
  if (udid != NULL) {
    set_has_udid();
  } else {
    clear_has_udid();
  }
  udid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), udid);
  // @@protoc_insertion_point(field_set_allocated:ccg_pb.login_DeviceReq.udid)
}

// required int32 DeviceType = 2;
inline bool login_DeviceReq::has_devicetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login_DeviceReq::set_has_devicetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login_DeviceReq::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login_DeviceReq::clear_devicetype() {
  devicetype_ = 0;
  clear_has_devicetype();
}
inline ::google::protobuf::int32 login_DeviceReq::devicetype() const {
  // @@protoc_insertion_point(field_get:ccg_pb.login_DeviceReq.DeviceType)
  return devicetype_;
}
inline void login_DeviceReq::set_devicetype(::google::protobuf::int32 value) {
  set_has_devicetype();
  devicetype_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.login_DeviceReq.DeviceType)
}

// -------------------------------------------------------------------

// login_wechatReq

// required string udid = 1;
inline bool login_wechatReq::has_udid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login_wechatReq::set_has_udid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login_wechatReq::clear_has_udid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login_wechatReq::clear_udid() {
  udid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_udid();
}
inline const ::std::string& login_wechatReq::udid() const {
  // @@protoc_insertion_point(field_get:ccg_pb.login_wechatReq.udid)
  return udid_.GetNoArena();
}
inline void login_wechatReq::set_udid(const ::std::string& value) {
  set_has_udid();
  udid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ccg_pb.login_wechatReq.udid)
}
#if LANG_CXX11
inline void login_wechatReq::set_udid(::std::string&& value) {
  set_has_udid();
  udid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ccg_pb.login_wechatReq.udid)
}
#endif
inline void login_wechatReq::set_udid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_udid();
  udid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ccg_pb.login_wechatReq.udid)
}
inline void login_wechatReq::set_udid(const char* value, size_t size) {
  set_has_udid();
  udid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ccg_pb.login_wechatReq.udid)
}
inline ::std::string* login_wechatReq::mutable_udid() {
  set_has_udid();
  // @@protoc_insertion_point(field_mutable:ccg_pb.login_wechatReq.udid)
  return udid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* login_wechatReq::release_udid() {
  // @@protoc_insertion_point(field_release:ccg_pb.login_wechatReq.udid)
  clear_has_udid();
  return udid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void login_wechatReq::set_allocated_udid(::std::string* udid) {
  if (udid != NULL) {
    set_has_udid();
  } else {
    clear_has_udid();
  }
  udid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), udid);
  // @@protoc_insertion_point(field_set_allocated:ccg_pb.login_wechatReq.udid)
}

// required int32 DeviceType = 2;
inline bool login_wechatReq::has_devicetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void login_wechatReq::set_has_devicetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void login_wechatReq::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void login_wechatReq::clear_devicetype() {
  devicetype_ = 0;
  clear_has_devicetype();
}
inline ::google::protobuf::int32 login_wechatReq::devicetype() const {
  // @@protoc_insertion_point(field_get:ccg_pb.login_wechatReq.DeviceType)
  return devicetype_;
}
inline void login_wechatReq::set_devicetype(::google::protobuf::int32 value) {
  set_has_devicetype();
  devicetype_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.login_wechatReq.DeviceType)
}

// required string headurl = 3;
inline bool login_wechatReq::has_headurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login_wechatReq::set_has_headurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login_wechatReq::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login_wechatReq::clear_headurl() {
  headurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_headurl();
}
inline const ::std::string& login_wechatReq::headurl() const {
  // @@protoc_insertion_point(field_get:ccg_pb.login_wechatReq.headurl)
  return headurl_.GetNoArena();
}
inline void login_wechatReq::set_headurl(const ::std::string& value) {
  set_has_headurl();
  headurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ccg_pb.login_wechatReq.headurl)
}
#if LANG_CXX11
inline void login_wechatReq::set_headurl(::std::string&& value) {
  set_has_headurl();
  headurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ccg_pb.login_wechatReq.headurl)
}
#endif
inline void login_wechatReq::set_headurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_headurl();
  headurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ccg_pb.login_wechatReq.headurl)
}
inline void login_wechatReq::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  headurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ccg_pb.login_wechatReq.headurl)
}
inline ::std::string* login_wechatReq::mutable_headurl() {
  set_has_headurl();
  // @@protoc_insertion_point(field_mutable:ccg_pb.login_wechatReq.headurl)
  return headurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* login_wechatReq::release_headurl() {
  // @@protoc_insertion_point(field_release:ccg_pb.login_wechatReq.headurl)
  clear_has_headurl();
  return headurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void login_wechatReq::set_allocated_headurl(::std::string* headurl) {
  if (headurl != NULL) {
    set_has_headurl();
  } else {
    clear_has_headurl();
  }
  headurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), headurl);
  // @@protoc_insertion_point(field_set_allocated:ccg_pb.login_wechatReq.headurl)
}

// required int32 type = 4;
inline bool login_wechatReq::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void login_wechatReq::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void login_wechatReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void login_wechatReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 login_wechatReq::type() const {
  // @@protoc_insertion_point(field_get:ccg_pb.login_wechatReq.type)
  return type_;
}
inline void login_wechatReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.login_wechatReq.type)
}

// -------------------------------------------------------------------

// login_Respone

// required int32 type = 1;
inline bool login_Respone::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login_Respone::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login_Respone::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login_Respone::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 login_Respone::type() const {
  // @@protoc_insertion_point(field_get:ccg_pb.login_Respone.type)
  return type_;
}
inline void login_Respone::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.login_Respone.type)
}

// required string nick = 2;
inline bool login_Respone::has_nick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login_Respone::set_has_nick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login_Respone::clear_has_nick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login_Respone::clear_nick() {
  nick_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nick();
}
inline const ::std::string& login_Respone::nick() const {
  // @@protoc_insertion_point(field_get:ccg_pb.login_Respone.nick)
  return nick_.GetNoArena();
}
inline void login_Respone::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ccg_pb.login_Respone.nick)
}
#if LANG_CXX11
inline void login_Respone::set_nick(::std::string&& value) {
  set_has_nick();
  nick_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ccg_pb.login_Respone.nick)
}
#endif
inline void login_Respone::set_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ccg_pb.login_Respone.nick)
}
inline void login_Respone::set_nick(const char* value, size_t size) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ccg_pb.login_Respone.nick)
}
inline ::std::string* login_Respone::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:ccg_pb.login_Respone.nick)
  return nick_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* login_Respone::release_nick() {
  // @@protoc_insertion_point(field_release:ccg_pb.login_Respone.nick)
  clear_has_nick();
  return nick_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void login_Respone::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick);
  // @@protoc_insertion_point(field_set_allocated:ccg_pb.login_Respone.nick)
}

// required int32 id = 3;
inline bool login_Respone::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void login_Respone::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void login_Respone::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void login_Respone::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 login_Respone::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.login_Respone.id)
  return id_;
}
inline void login_Respone::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.login_Respone.id)
}

// -------------------------------------------------------------------

// room_createReq

// required int32 id = 1;
inline bool room_createReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void room_createReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void room_createReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void room_createReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 room_createReq::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.room_createReq.id)
  return id_;
}
inline void room_createReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.room_createReq.id)
}

// required int32 roomtype = 2;
inline bool room_createReq::has_roomtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void room_createReq::set_has_roomtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void room_createReq::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void room_createReq::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 room_createReq::roomtype() const {
  // @@protoc_insertion_point(field_get:ccg_pb.room_createReq.roomtype)
  return roomtype_;
}
inline void room_createReq::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.room_createReq.roomtype)
}

// -------------------------------------------------------------------

// room_createRespone

// required int32 errorcode = 1;
inline bool room_createRespone::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void room_createRespone::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void room_createRespone::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void room_createRespone::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 room_createRespone::errorcode() const {
  // @@protoc_insertion_point(field_get:ccg_pb.room_createRespone.errorcode)
  return errorcode_;
}
inline void room_createRespone::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.room_createRespone.errorcode)
}

// required int32 roomid = 2;
inline bool room_createRespone::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void room_createRespone::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void room_createRespone::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void room_createRespone::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 room_createRespone::roomid() const {
  // @@protoc_insertion_point(field_get:ccg_pb.room_createRespone.roomid)
  return roomid_;
}
inline void room_createRespone::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.room_createRespone.roomid)
}

// -------------------------------------------------------------------

// room_joinReq

// required int32 id = 1;
inline bool room_joinReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void room_joinReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void room_joinReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void room_joinReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 room_joinReq::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.room_joinReq.id)
  return id_;
}
inline void room_joinReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.room_joinReq.id)
}

// required int32 roomid = 2;
inline bool room_joinReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void room_joinReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void room_joinReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void room_joinReq::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 room_joinReq::roomid() const {
  // @@protoc_insertion_point(field_get:ccg_pb.room_joinReq.roomid)
  return roomid_;
}
inline void room_joinReq::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.room_joinReq.roomid)
}

// -------------------------------------------------------------------

// room_joinRespone

// required int32 errorcode = 1;
inline bool room_joinRespone::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void room_joinRespone::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void room_joinRespone::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void room_joinRespone::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 room_joinRespone::errorcode() const {
  // @@protoc_insertion_point(field_get:ccg_pb.room_joinRespone.errorcode)
  return errorcode_;
}
inline void room_joinRespone::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.room_joinRespone.errorcode)
}

// repeated .ccg_pb.PlayerData pd = 2;
inline int room_joinRespone::pd_size() const {
  return pd_.size();
}
inline void room_joinRespone::clear_pd() {
  pd_.Clear();
}
inline const ::ccg_pb::PlayerData& room_joinRespone::pd(int index) const {
  // @@protoc_insertion_point(field_get:ccg_pb.room_joinRespone.pd)
  return pd_.Get(index);
}
inline ::ccg_pb::PlayerData* room_joinRespone::mutable_pd(int index) {
  // @@protoc_insertion_point(field_mutable:ccg_pb.room_joinRespone.pd)
  return pd_.Mutable(index);
}
inline ::ccg_pb::PlayerData* room_joinRespone::add_pd() {
  // @@protoc_insertion_point(field_add:ccg_pb.room_joinRespone.pd)
  return pd_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ccg_pb::PlayerData >*
room_joinRespone::mutable_pd() {
  // @@protoc_insertion_point(field_mutable_list:ccg_pb.room_joinRespone.pd)
  return &pd_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ccg_pb::PlayerData >&
room_joinRespone::pd() const {
  // @@protoc_insertion_point(field_list:ccg_pb.room_joinRespone.pd)
  return pd_;
}

// -------------------------------------------------------------------

// room_playerReady

// required int32 id = 1;
inline bool room_playerReady::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void room_playerReady::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void room_playerReady::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void room_playerReady::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 room_playerReady::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.room_playerReady.id)
  return id_;
}
inline void room_playerReady::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.room_playerReady.id)
}

// -------------------------------------------------------------------

// room_playerReadyRespone

// required int32 id = 1;
inline bool room_playerReadyRespone::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void room_playerReadyRespone::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void room_playerReadyRespone::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void room_playerReadyRespone::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 room_playerReadyRespone::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.room_playerReadyRespone.id)
  return id_;
}
inline void room_playerReadyRespone::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.room_playerReadyRespone.id)
}

// -------------------------------------------------------------------

// room_gamestartRespone

// required int32 id = 1;
inline bool room_gamestartRespone::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void room_gamestartRespone::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void room_gamestartRespone::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void room_gamestartRespone::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 room_gamestartRespone::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.room_gamestartRespone.id)
  return id_;
}
inline void room_gamestartRespone::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.room_gamestartRespone.id)
}

// repeated .ccg_pb.poker pk = 2;
inline int room_gamestartRespone::pk_size() const {
  return pk_.size();
}
inline void room_gamestartRespone::clear_pk() {
  pk_.Clear();
}
inline const ::ccg_pb::poker& room_gamestartRespone::pk(int index) const {
  // @@protoc_insertion_point(field_get:ccg_pb.room_gamestartRespone.pk)
  return pk_.Get(index);
}
inline ::ccg_pb::poker* room_gamestartRespone::mutable_pk(int index) {
  // @@protoc_insertion_point(field_mutable:ccg_pb.room_gamestartRespone.pk)
  return pk_.Mutable(index);
}
inline ::ccg_pb::poker* room_gamestartRespone::add_pk() {
  // @@protoc_insertion_point(field_add:ccg_pb.room_gamestartRespone.pk)
  return pk_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker >*
room_gamestartRespone::mutable_pk() {
  // @@protoc_insertion_point(field_mutable_list:ccg_pb.room_gamestartRespone.pk)
  return &pk_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker >&
room_gamestartRespone::pk() const {
  // @@protoc_insertion_point(field_list:ccg_pb.room_gamestartRespone.pk)
  return pk_;
}

// -------------------------------------------------------------------

// poker

// required int32 id = 1;
inline bool poker::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void poker::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void poker::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void poker::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 poker::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.poker.id)
  return id_;
}
inline void poker::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.poker.id)
}

// required int32 type = 2;
inline bool poker::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void poker::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void poker::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void poker::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 poker::type() const {
  // @@protoc_insertion_point(field_get:ccg_pb.poker.type)
  return type_;
}
inline void poker::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.poker.type)
}

// -------------------------------------------------------------------

// call

// required int32 id = 1;
inline bool call::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void call::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void call::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void call::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 call::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.call.id)
  return id_;
}
inline void call::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.call.id)
}

// required int32 num = 2;
inline bool call::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void call::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void call::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void call::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 call::num() const {
  // @@protoc_insertion_point(field_get:ccg_pb.call.num)
  return num_;
}
inline void call::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.call.num)
}

// -------------------------------------------------------------------

// call_Respone

// required int32 id = 1;
inline bool call_Respone::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void call_Respone::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void call_Respone::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void call_Respone::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 call_Respone::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.call_Respone.id)
  return id_;
}
inline void call_Respone::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.call_Respone.id)
}

// required int32 num = 2;
inline bool call_Respone::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void call_Respone::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void call_Respone::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void call_Respone::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 call_Respone::num() const {
  // @@protoc_insertion_point(field_get:ccg_pb.call_Respone.num)
  return num_;
}
inline void call_Respone::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.call_Respone.num)
}

// required int32 nextcallid = 3;
inline bool call_Respone::has_nextcallid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void call_Respone::set_has_nextcallid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void call_Respone::clear_has_nextcallid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void call_Respone::clear_nextcallid() {
  nextcallid_ = 0;
  clear_has_nextcallid();
}
inline ::google::protobuf::int32 call_Respone::nextcallid() const {
  // @@protoc_insertion_point(field_get:ccg_pb.call_Respone.nextcallid)
  return nextcallid_;
}
inline void call_Respone::set_nextcallid(::google::protobuf::int32 value) {
  set_has_nextcallid();
  nextcallid_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.call_Respone.nextcallid)
}

// -------------------------------------------------------------------

// call_begin_Respone

// required int32 id = 1;
inline bool call_begin_Respone::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void call_begin_Respone::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void call_begin_Respone::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void call_begin_Respone::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 call_begin_Respone::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.call_begin_Respone.id)
  return id_;
}
inline void call_begin_Respone::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.call_begin_Respone.id)
}

// required int32 num = 2;
inline bool call_begin_Respone::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void call_begin_Respone::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void call_begin_Respone::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void call_begin_Respone::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 call_begin_Respone::num() const {
  // @@protoc_insertion_point(field_get:ccg_pb.call_begin_Respone.num)
  return num_;
}
inline void call_begin_Respone::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.call_begin_Respone.num)
}

// -------------------------------------------------------------------

// pokerout

// required int32 id = 1;
inline bool pokerout::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pokerout::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pokerout::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pokerout::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 pokerout::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.pokerout.id)
  return id_;
}
inline void pokerout::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.pokerout.id)
}

// repeated .ccg_pb.poker pk = 2;
inline int pokerout::pk_size() const {
  return pk_.size();
}
inline void pokerout::clear_pk() {
  pk_.Clear();
}
inline const ::ccg_pb::poker& pokerout::pk(int index) const {
  // @@protoc_insertion_point(field_get:ccg_pb.pokerout.pk)
  return pk_.Get(index);
}
inline ::ccg_pb::poker* pokerout::mutable_pk(int index) {
  // @@protoc_insertion_point(field_mutable:ccg_pb.pokerout.pk)
  return pk_.Mutable(index);
}
inline ::ccg_pb::poker* pokerout::add_pk() {
  // @@protoc_insertion_point(field_add:ccg_pb.pokerout.pk)
  return pk_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker >*
pokerout::mutable_pk() {
  // @@protoc_insertion_point(field_mutable_list:ccg_pb.pokerout.pk)
  return &pk_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker >&
pokerout::pk() const {
  // @@protoc_insertion_point(field_list:ccg_pb.pokerout.pk)
  return pk_;
}

// -------------------------------------------------------------------

// pokerout_Respone

// required int32 id = 1;
inline bool pokerout_Respone::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pokerout_Respone::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pokerout_Respone::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pokerout_Respone::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 pokerout_Respone::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.pokerout_Respone.id)
  return id_;
}
inline void pokerout_Respone::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.pokerout_Respone.id)
}

// repeated .ccg_pb.poker pk = 2;
inline int pokerout_Respone::pk_size() const {
  return pk_.size();
}
inline void pokerout_Respone::clear_pk() {
  pk_.Clear();
}
inline const ::ccg_pb::poker& pokerout_Respone::pk(int index) const {
  // @@protoc_insertion_point(field_get:ccg_pb.pokerout_Respone.pk)
  return pk_.Get(index);
}
inline ::ccg_pb::poker* pokerout_Respone::mutable_pk(int index) {
  // @@protoc_insertion_point(field_mutable:ccg_pb.pokerout_Respone.pk)
  return pk_.Mutable(index);
}
inline ::ccg_pb::poker* pokerout_Respone::add_pk() {
  // @@protoc_insertion_point(field_add:ccg_pb.pokerout_Respone.pk)
  return pk_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker >*
pokerout_Respone::mutable_pk() {
  // @@protoc_insertion_point(field_mutable_list:ccg_pb.pokerout_Respone.pk)
  return &pk_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ccg_pb::poker >&
pokerout_Respone::pk() const {
  // @@protoc_insertion_point(field_list:ccg_pb.pokerout_Respone.pk)
  return pk_;
}

// required int32 nextid = 3;
inline bool pokerout_Respone::has_nextid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pokerout_Respone::set_has_nextid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pokerout_Respone::clear_has_nextid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pokerout_Respone::clear_nextid() {
  nextid_ = 0;
  clear_has_nextid();
}
inline ::google::protobuf::int32 pokerout_Respone::nextid() const {
  // @@protoc_insertion_point(field_get:ccg_pb.pokerout_Respone.nextid)
  return nextid_;
}
inline void pokerout_Respone::set_nextid(::google::protobuf::int32 value) {
  set_has_nextid();
  nextid_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.pokerout_Respone.nextid)
}

// -------------------------------------------------------------------

// gameend_Respone

// -------------------------------------------------------------------

// chattext

// required int32 id = 1;
inline bool chattext::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chattext::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chattext::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chattext::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 chattext::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.chattext.id)
  return id_;
}
inline void chattext::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.chattext.id)
}

// required int32 textid = 2;
inline bool chattext::has_textid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chattext::set_has_textid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chattext::clear_has_textid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chattext::clear_textid() {
  textid_ = 0;
  clear_has_textid();
}
inline ::google::protobuf::int32 chattext::textid() const {
  // @@protoc_insertion_point(field_get:ccg_pb.chattext.textid)
  return textid_;
}
inline void chattext::set_textid(::google::protobuf::int32 value) {
  set_has_textid();
  textid_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.chattext.textid)
}

// -------------------------------------------------------------------

// chatemo

// required int32 id = 1;
inline bool chatemo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chatemo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chatemo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chatemo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 chatemo::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.chatemo.id)
  return id_;
}
inline void chatemo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.chatemo.id)
}

// required int32 emoid = 2;
inline bool chatemo::has_emoid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chatemo::set_has_emoid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chatemo::clear_has_emoid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chatemo::clear_emoid() {
  emoid_ = 0;
  clear_has_emoid();
}
inline ::google::protobuf::int32 chatemo::emoid() const {
  // @@protoc_insertion_point(field_get:ccg_pb.chatemo.emoid)
  return emoid_;
}
inline void chatemo::set_emoid(::google::protobuf::int32 value) {
  set_has_emoid();
  emoid_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.chatemo.emoid)
}

// -------------------------------------------------------------------

// chatstring

// required int32 id = 1;
inline bool chatstring::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chatstring::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chatstring::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chatstring::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 chatstring::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.chatstring.id)
  return id_;
}
inline void chatstring::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.chatstring.id)
}

// required string str = 2;
inline bool chatstring::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chatstring::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chatstring::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chatstring::clear_str() {
  str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_str();
}
inline const ::std::string& chatstring::str() const {
  // @@protoc_insertion_point(field_get:ccg_pb.chatstring.str)
  return str_.GetNoArena();
}
inline void chatstring::set_str(const ::std::string& value) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ccg_pb.chatstring.str)
}
#if LANG_CXX11
inline void chatstring::set_str(::std::string&& value) {
  set_has_str();
  str_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ccg_pb.chatstring.str)
}
#endif
inline void chatstring::set_str(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ccg_pb.chatstring.str)
}
inline void chatstring::set_str(const char* value, size_t size) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ccg_pb.chatstring.str)
}
inline ::std::string* chatstring::mutable_str() {
  set_has_str();
  // @@protoc_insertion_point(field_mutable:ccg_pb.chatstring.str)
  return str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* chatstring::release_str() {
  // @@protoc_insertion_point(field_release:ccg_pb.chatstring.str)
  clear_has_str();
  return str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void chatstring::set_allocated_str(::std::string* str) {
  if (str != NULL) {
    set_has_str();
  } else {
    clear_has_str();
  }
  str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str);
  // @@protoc_insertion_point(field_set_allocated:ccg_pb.chatstring.str)
}

// -------------------------------------------------------------------

// chattext_Respone

// required int32 id = 1;
inline bool chattext_Respone::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chattext_Respone::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chattext_Respone::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chattext_Respone::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 chattext_Respone::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.chattext_Respone.id)
  return id_;
}
inline void chattext_Respone::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.chattext_Respone.id)
}

// required int32 textid = 2;
inline bool chattext_Respone::has_textid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chattext_Respone::set_has_textid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chattext_Respone::clear_has_textid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chattext_Respone::clear_textid() {
  textid_ = 0;
  clear_has_textid();
}
inline ::google::protobuf::int32 chattext_Respone::textid() const {
  // @@protoc_insertion_point(field_get:ccg_pb.chattext_Respone.textid)
  return textid_;
}
inline void chattext_Respone::set_textid(::google::protobuf::int32 value) {
  set_has_textid();
  textid_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.chattext_Respone.textid)
}

// -------------------------------------------------------------------

// chatemo_Respone

// required int32 id = 1;
inline bool chatemo_Respone::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chatemo_Respone::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chatemo_Respone::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chatemo_Respone::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 chatemo_Respone::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.chatemo_Respone.id)
  return id_;
}
inline void chatemo_Respone::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.chatemo_Respone.id)
}

// required int32 emoid = 2;
inline bool chatemo_Respone::has_emoid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chatemo_Respone::set_has_emoid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chatemo_Respone::clear_has_emoid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chatemo_Respone::clear_emoid() {
  emoid_ = 0;
  clear_has_emoid();
}
inline ::google::protobuf::int32 chatemo_Respone::emoid() const {
  // @@protoc_insertion_point(field_get:ccg_pb.chatemo_Respone.emoid)
  return emoid_;
}
inline void chatemo_Respone::set_emoid(::google::protobuf::int32 value) {
  set_has_emoid();
  emoid_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.chatemo_Respone.emoid)
}

// -------------------------------------------------------------------

// chatstring_Respone

// required int32 id = 1;
inline bool chatstring_Respone::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chatstring_Respone::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chatstring_Respone::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chatstring_Respone::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 chatstring_Respone::id() const {
  // @@protoc_insertion_point(field_get:ccg_pb.chatstring_Respone.id)
  return id_;
}
inline void chatstring_Respone::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ccg_pb.chatstring_Respone.id)
}

// required string str = 2;
inline bool chatstring_Respone::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chatstring_Respone::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chatstring_Respone::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chatstring_Respone::clear_str() {
  str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_str();
}
inline const ::std::string& chatstring_Respone::str() const {
  // @@protoc_insertion_point(field_get:ccg_pb.chatstring_Respone.str)
  return str_.GetNoArena();
}
inline void chatstring_Respone::set_str(const ::std::string& value) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ccg_pb.chatstring_Respone.str)
}
#if LANG_CXX11
inline void chatstring_Respone::set_str(::std::string&& value) {
  set_has_str();
  str_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ccg_pb.chatstring_Respone.str)
}
#endif
inline void chatstring_Respone::set_str(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ccg_pb.chatstring_Respone.str)
}
inline void chatstring_Respone::set_str(const char* value, size_t size) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ccg_pb.chatstring_Respone.str)
}
inline ::std::string* chatstring_Respone::mutable_str() {
  set_has_str();
  // @@protoc_insertion_point(field_mutable:ccg_pb.chatstring_Respone.str)
  return str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* chatstring_Respone::release_str() {
  // @@protoc_insertion_point(field_release:ccg_pb.chatstring_Respone.str)
  clear_has_str();
  return str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void chatstring_Respone::set_allocated_str(::std::string* str) {
  if (str != NULL) {
    set_has_str();
  } else {
    clear_has_str();
  }
  str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str);
  // @@protoc_insertion_point(field_set_allocated:ccg_pb.chatstring_Respone.str)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ccg_pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_addressbook_2eproto__INCLUDED
